slug: gke-microservices
id: 3ugxzwhjqfp6
type: track
title: Kubernetes Engine
teaser: Are you a master of microservices?
description: |-
  Kubernetes Engine is a managed, production-ready environment for deploying and managing containerized applications. It brings our latest innovations in developer productivity, resource efficiency, automated operations, and open source flexibility to accelerate your time to market.

  Kubernetes gives you the power to create, deploy and manage microservices, and Kubernetes Engine gives you this power in a fully managed environment.

  Are you a GKE expert? Think you have what it takes to manage some microservices? Let's find out!
icon: https://storage.googleapis.com/instruqt-shadow-resources/gke_spinning.gif
tags:
- kubernetes
- ' google'
- ' containers'
- ' microservices'
owner: google
developers:
- sandeepdinesh@google.com
private: false
published: true
challenges:
- slug: create-a-namespace
  id: r3bxw1jxvzfm
  type: challenge
  title: Create a namespace
  teaser: Let's start easy
  assignment: |-
    A GKE Cluster has been provisioned for you, and the **kubectl** CLI has been pre-authenticated.

    Create a namespace called **challenge**
  notes:
  - type: text
    contents: "Google Kubernetes Engine is a **fully managed and enterprise grade**
      Kubernetes platform. \n\nWith Kubernetes Engine you can focus on deploying and
      managing **containerized microservices** while leaving the **node, network,
      and other low level maintenance** to Google."
  - type: text
    contents: "Kubernetes Engine is a **Certified Kubernetes** platform with many
      additional features designed to give you the power and flexibility you need.
      \n\nFrom **built in autoscaling, VPC native networking, global load balancing,
      and addons like Knative and Istio**, Kubernetes Engine gives you the tools you
      need to build **cloud native applications**."
  - type: text
    contents: One of the most important concepts in Kubernetes is that of a **Namespace**.
      Namespaces are used to organize resources in your cluster.
  tabs:
  - title: Shell
    type: terminal
    hostname: shell
  difficulty: basic
  timelimit: 300
- slug: deployment
  id: ibrsq1fnrxyx
  type: challenge
  title: Deployments
  teaser: Running your microservice
  assignment: |-
    In the **challenge** namespace you previously created, create a **Deployment** called **frontend-deployment** that runs a single Pod with the **gcr.io/gke-arcade/challenge** image.
    The Pod should be labeled with **role = frontend**.
    There is a partial file called `deployment.yaml` that has been created for you to use.
  notes:
  - type: text
    contents: One of the fundamental building blocks of Kubernetes is the **Pod**.
      Pods are a group of one or more containers that are scheduled together, for
      example a web server and a log collector.
  - type: text
    contents: Pods are scheduled onto the cluster with a scheduler. The most common
      scheduler is a **Deployment**. Deployments let you run, scale, and update your
      Pods in a declarative fashion.
  tabs:
  - title: Shell
    type: terminal
    hostname: shell
  difficulty: basic
  timelimit: 500
- slug: service
  id: sxvpvju1jlg5
  type: challenge
  title: Services
  teaser: Exposing your microservice to the world
  assignment: |-
    In the **challenge** namespace you previously created, create a **Service** called **frontend-service** of type **LoadBalancer** that routes traffic from port 80 to port 3000 of the pods in the `frontend-deployment` Deployment.

    (remember, the pods are labeled "role = frontend")

    cURL the exposed service, and save the output of the service to a file called **output.txt**

    There is another partial file called `service.yaml` that has been created for you to use.
  notes:
  - type: text
    contents: "While Deployments run your containers, **Services** tie them all together.
      Services act a service discovery and load balancing endpoints for your microservices.
      \nThis allows you to run multiple copies of your app without worrying about
      how other microservices in the cluster will find them."
  - type: text
    contents: Services also let you create Network Load Balancers on GCP, allowing
      you to expose your microservices directly to the world behind an automatically
      configured and scalable load balancer.
  tabs:
  - title: Shell
    type: terminal
    hostname: shell
  difficulty: basic
  timelimit: 600
- slug: configmaps-secrets
  id: gyahomlke8uv
  type: challenge
  title: ConfigMaps and Secrets
  teaser: Harness the power of distributed environment variables
  assignment: |-
    In the **challenge** namespace you previously created, create a **ConfigMap** called **prod-configmap** with a key named **username** with _any value_.

    Then create a **generic Secret** called **prod-secret** with a key named **password** with _any value_ in the **challenge namespace**.
  notes:
  - type: text
    contents: 'Running your containers is just the tip of the iceberg when it comes
      to Kubernetes. Configuring and managing your app is equally important. Kubernetes
      provides two powerful config management primitives out of the box: **ConfigMaps**
      and **Secrets**'
  - type: text
    contents: Kubernetes **ConfigMaps** allow you to decouple configuration artifacts
      from image content to keep containerized applications portable. ConfigMaps allow
      environment specific data and files to be injected into your containers at runtime,
      allowing containers to be reused more easily.
  - type: text
    contents: Kubernetes **Secrets** are similar, except they are for storing confidential
      information.
  tabs:
  - title: Shell
    type: terminal
    hostname: shell
  difficulty: basic
  timelimit: 600
- slug: combined
  id: yyvnqbslzg1g
  type: challenge
  title: Putting it all together
  teaser: A short description of the challenge.
  assignment: |-
    Update the **frontend-deployment** Deployment to have an **environment variable** called **USERNAME** that gets its value from the ConfigMap you created, and another environment variable called **PASSWORD** that gets is value from the Secret you created.

    cURL the exposed service, and save the output of the service to a file called **finished.txt**

    The `deployment.yaml` file has been updated for you to use.
  tabs:
  - title: Shell
    type: terminal
    hostname: shell
  difficulty: basic
  timelimit: 500
checksum: "17483426234787904478"
