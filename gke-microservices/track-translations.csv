key,en,zh-cn,ko,zh-tw
slug,gke-microservices,gke-microservices-simplifiedchinese,gke-microservices-ko,gke-microservices-zh-tw
teaser,Are you a master of microservices?,您是否精通微服务？,마이크로서비스 전문가이신가요?,您熟悉微服務嗎？
description,"Kubernetes Engine is a managed, production-ready environment for deploying and managing containerized applications. It brings our latest innovations in developer productivity, resource efficiency, automated operations, and open source flexibility to accelerate your time to market.",Kubernetes Engine 是一种支持生产工作负载的托管式环境，可用于部署和管理容器化应用。它提供我们在开发者工作效率、资源效率、自动化运维和开源灵活性领域的最新创新技术，帮助您缩短产品上市时间。,"Kubernetes Engine은 컨테이너형 애플리케이션의 배포 및 관리를 위한 관리형 프로덕션 환경입니다. 이 도구는 개발자 생산성, 리소스 효율성, 자동화된 운영, 오픈소스 유연성에 혁신을 가져와 TTM(Time To Market)을 단축합니다.",Kubernetes Engine 是一種代管環境，可用於部署及管理容器化應用程式，讓您輕鬆處理實際工作環境中的作業。這項服務整合了 Google 在開發人員生產力、資源運用效率、自動化作業和開放原始碼靈活性等方面的最新技術，可縮短應用程式的上市時間。
namespace-assignment,"A GKE Cluster has been provisioned for you, and the **kubectl** CLI has been pre-authenticated.\n\nCreate a namespace called **challenge**",系统已为您预配了一个 GKE 集群，并且已预先对 **kubectl** CLI 进行了身份验证。\n\n创建一个名为 **challenge** 的命名空间,GKE 클러스터가 프로비저닝되고 **kubectl** CLI가 사전에 인증되었습니다.\n\n**challenge**라는 네임스페이스를 만드세요.,我們為您佈建了 GKE 叢集，並已預先驗證 **kubectl** CLI。\n\n請建立名為 **challenge** 的命名空間
namespace-notes-1,"Google Kubernetes Engine is a **fully managed and enterprise grade** Kubernetes platform. \n\nWith Kubernetes Engine you can focus on deploying and managing **containerized microservices** while leaving the **node, network, and other low level maintenance** to Google.",Google Kubernetes Engine 是一个**完全托管的企业级** Kubernetes 平台。\n\n利用 Kubernetes Engine，您可以集中精力来部署和管理**容器化微服务**，而将**节点、网络和其他低级别的维护工作**交给 Google 处理。,"Google Kubernetes Engine은 **완전 관리형 엔터프라이즈 수준**의 Kubernetes 플랫폼입니다. \n\nKubernetes Engine을 사용하면 **노드, 네트워크, 하위 수준의 유지보수**를 Google에 맡기고, **컨테이너형 마이크로서비스**를 집중적으로 배포하고 관리할 수 있습니다.",Google Kubernetes Engine 是 **全代管的企業級** Kubernetes 平台。 \n\n有了 Kubernetes Engine，您就能專心部署及管理**容器化微服務**，同時將**節點、網路和其他基礎維護工作**交給 Google 處理。
namespace-notes-2,"Kubernetes Engine is a **Certified Kubernetes** platform with many additional features designed to give you the power and flexibility you need. \n\nFrom **built in autoscaling, VPC native networking, global load balancing, and addons like Knative and Istio**, Kubernetes Engine gives you the tools you need to build **cloud native applications**.",Kubernetes Engine 是**经过认证的 Kubernetes**平台，还提供许多额外的功能，旨在为您提供所需的处理能力和灵活性。\n\n从**内置自动扩缩、VPC 原生网络、全局负载平衡，到 Knative 和 Istio 等插件**，Kubernetes Engine 为您提供了构建**云原生应用**所需的一切工具。,"Kubernetes Engine은 필요한 성능과 유연성을 제공하도록 만들어진 다양한 추가 기능을 갖춘 **Certified Kubernetes** 플랫폼입니다. \n\nKubernetes Engine은 **내장된 자동 확장, VPC 기반 네트워킹, 글로벌 부하 분산을 비롯해 Knative 및 Istio와 같은 부가기능**까지 **클라우드 기반 애플리케이션**을 빌드하기 위해 필요한 도구를 제공합니다.",Kubernetes Engine 是**經過認證的 Kubernetes** 平台，具備許多額外功能，可以為您提供各項必要的服務，而且使用起來十分具有彈性。 \n\nKubernetes Engine 提供建構**雲端原生應用程式**所需的工具，例如**內建的自動調度資源、虛擬私人雲端原生網路和全球負載平衡功能，以及 Knative 和 Istio 等外掛程式**。
namespace-notes-3,One of the most important concepts in Kubernetes is that of a **Namespace**. Namespaces are used to organize resources in your cluster.,Kubernetes 中最重要的概念之一是**命名空间**。命名空间用于整理集群中的资源。,**네임스페에스**는 Kubernetes에서 가장 중요하게 여기는 개념 중 하나로 클러스터에서 리소스를 관리하는 데 사용됩니다.,Kubernetes 最重要的概念之一即為 **命名空間**。您可以使用命名空間來整理叢集中的資源。
deployment-assignment,"In the **challenge** namespace you previously created, create a **Deployment** called **frontend-deployment** that runs a single Pod with the **gcr.io/gke-arcade/challenge** image.\nThe Pod should be labeled with **role = frontend**.\nThere is a partial file called `deployment.yaml` that has been created for you to use.",在您之前创建的 **challenge** 命名空间中，创建一个名为 **frontend-deployment**、运行使用 **gcr.io/gke-arcade/challenge** 映像的单个 Pod 的**部署**。\n此 Pod 应具有 **role = frontend** 标签。\n系统创建了一个名为“deployment.yaml”的部分文件供您使用。,이전에 만든 **challenge** 네임스페이스에서 **gcr.io/gke-arcade/challenge** 이미지로 단일 Pod를 실행하는 **frontend-deployment**라는 **Deployment**를 만드세요.\nPod에 **role = frontend** 라벨을 지정해야 합니다.\n`deployment.yaml`이라는 부분 파일도 사용할 수 있도록 만들어져 있습니다.,請在稍早建立的 **challenge** 命名空間中建立名為 **frontend-deployment** 的 **Deployment**，這項 Deployment 會透過 **gcr.io/gke-arcade/challenge** 映像檔執行一個 pod。\n不過，請務必為該 pod 加上 **role = frontend** 標籤。\n我們已為您建立名為「deployment.yaml」的局部檔案，可供您使用。
deployment-notes-1,"One of the fundamental building blocks of Kubernetes is the **Pod**. Pods are a group of one or more containers that are scheduled together, for example a web server and a log collector.",Kubernetes 的基本构件之一是 **Pod**。Pod 是一同调度的一组（一个或多个）容器，例如 Web 服务器或日志收集器。,"Kubernetes의 기본적인 구성 요소 중 하나는 **Pod**입니다. Pod는 웹 서버 및 로그 수집기와 같이, 함께 예약된 하나 이상의 컨테이너 그룹입니다.",Kubernetes 的基本建構元件之一是 **pod**。pod 由一或多個時程相同的容器組成，例如網路伺服器和記錄檔收集工具。
deployment-notes-2,"Pods are scheduled onto the cluster with a scheduler. The most common scheduler is a **Deployment**. Deployments let you run, scale, and update your Pods in a declarative fashion.",Pod 由调度程序调度到集群中。最常用的调度程序是**部署**。部署允许您以声明式方式运行、扩缩和更新 Pod。,"Pod는 스케줄러를 사용하여 클러스터에 예약됩니다. 가장 일반적인 스케줄러는 **Deployment**입니다. Deployment를 사용하면 선언적인 방식으로 Pod를 실행, 확장, 업데이트할 수 있습니다.",系統會利用排程器將 pod 安排至叢集。最常見的排程器是 **Deployment**。Deployment 可讓您透過陳述式執行及更新 pod，並為其調度資源。
service-assignment,"In the **challenge** namespace you previously created, create a **Service** called **frontend-service** of type **LoadBalancer** that routes traffic from port 80 to port 3000 of the pods in the `frontend-deployment` Deployment.\n\n(remember, the pods are labeled ""role = frontend"")\n\ncURL the exposed service, and save the output of the service to a file called **output.txt**\n\nThere is another partial file called `service.yaml` that has been created for you to use.",在您之前创建的 **challenge** 命名空间中，创建一项名为 **frontend-service**、类型为 **LoadBalancer** 的**服务**，用于将端口 80 上的流量路由到“frontend-deployment”部署中的 Pod 的端口 3000。\n\n（请记住，这些 Pod 具有“role = frontend”标签）\n\n对公开的服务运行 cURL 命令，并将服务的输出保存至一个名为 **output.txt** 的文件。\n\n系统还创建了一个名为“service.yaml”的部分文件供您使用。,이전에 만든 **challenge** 네임스페이스에서 `frontend-deployment` Deployment에 있는 pod의 포트 80에서 포트 3000으로 트래픽을 라우팅하는 **LoadBalancer** 유형의 **frontend-service**라는 **서비스**를 만드세요.\n\n(주의: pod 라벨은 'role = frontend'로 지정해야 합니다.)\n\n제공된 서비스를 cURL로 실행하고 서비스 출력을 **output.txt**라는 파일에 저장하세요.\n\n`service.yaml`이라는 다른 부분 파일도 사용할 수 있도록 생성되어 있습니다.,請在您稍早建立的 **challenge** 命名空間中建立名為 **frontend-service** 的 **Service**，該項 Service 的類型為 **LoadBalancer**，可用來將流量從「frontend-deployment」Deployment 中 pod 的通訊埠 80 轉送至通訊埠 3000。\n\n請注意，這些 pod 已含「role = frontend」標籤。\n\n使用 cURL 執行已公開發布的服務，並將該項服務的輸出內容儲存至名為 **output.txt** 的檔案\n\n我們已為您建立另一個名為「service.yaml」的局部檔案，可供您使用。
service-notes-1,"While Deployments run your containers, **Services** tie them all together. Services act a service discovery and load balancing endpoints for your microservices. \nThis allows you to run multiple copies of your app without worrying about how other microservices in the cluster will find them.",部署运行容器，而**服务**将容器全部绑定到一起。服务充当微服务的服务发现和负载平衡端点。\n这样，您可以运行应用的多个副本，而不必担心集群中的其他微服务如何找到它们。,Deployment가 컨테이너를 실행하는 동안 **서비스**가 이를 하나로 묶습니다. 서비스는 마이크로서비스를 위한 서비스 검색 및 부하 분산 엔드포인트로 작동합니다. \n그러면 클러스터에 있는 다른 마이크로서비스가 앱 사본을 찾는 방법을 걱정할 필요 없이 앱의 여러 사본을 실행할 수 있습니다.,Deployment 執行您的容器時，**Service** 會將所有容器相互繫結。Service 可用來當做微服務的服務探索和負載平衡端點。\n這樣一來，您就能執行應用程式的多個副本，而且不必擔心叢集中的其他微服務要透過何種方式找到這些副本。
service-notes-2,"Services also let you create Network Load Balancers on GCP, allowing you to expose your microservices directly to the world behind an automatically configured and scalable load balancer.",利用服务，您还可以在 GCP 上创建网络负载平衡器，从而通过自动配置的可扩缩负载平衡器直接向世界公开您的微服务。,또한 GCP에서 서비스를 사용하여 네트워크 부하 분산기를 만들어 자동으로 구성되고 확장 가능한 부하 분산기 이면의 환경에 직접 마이크로서비스를 노출할 수 있습니다.,另外，Service 也能讓您在 GCP 中建立網路負載平衡器，以便在系統自動設定的擴充式負載平衡器後方直接將微服務發布至全世界。
configmaps-secrets-assignment,"In the **challenge** namespace you previously created, create a **ConfigMap** called **prod-configmap** with a key named **username** with _any value_.\n\nThen create a **generic Secret** called **prod-secret** with a key named **password** with _any value_ in the **challenge namespace**.",在您之前创建的 **challenge** 命名空间中，创建一个名为 **prod-configmap** 的 **ConfigMap**，它具有值为_任意值_的 **username** 的键。\n\n然后在 **challenge 命名空间**中创建一个名为 **prod-secret** 的**常规 Secret**，它具有值为_任意值_的 **password** 的键。,이전에 만든 **challenge** 네임스페이스에서 _아무 값_이나 포함된 **username**이라는 키를 사용해 **prod-configmap**이라는 **ConfigMap**을 만드세요.\n\n그런 다음 **challenge 네임스페이스**에 있는 _아무 값_이나 포함된 **password**라는 키를 사용해 **prod-secret**이라는 **일반 Secret**을 만드세요.,請在您稍早建立的 **challenge** 命名空間中建立名為 **prod-configmap** 的 **ConfigMap**；使用的鍵名為 **username**，可自行設定任意值。\n\n接著，請在 **challenge 命名空間**中建立名為 **prod-secret** 的**一般 Secret**；使用的鍵名為 **password**，可自行設定任意值。
configmaps-secrets-notes-1,Running your containers is just the tip of the iceberg when it comes to Kubernetes. Configuring and managing your app is equally important. Kubernetes provides two powerful config management primitives out of the box: **ConfigMaps** and **Secrets**,对于 Kubernetes ，运行容器只是冰山一角。配置和管理应用同样重要。Kubernetes 提供两种现成的功能强大的配置管理基本组件：**ConfigMap** 和 **Secret**,Kubernetes에서의 컨테이너 실행은 빙산의 일각에 불과합니다. 앱을 구성하고 관리하는 것도 마찬가지로 중요합니다. Kubernetes는 **ConfigMaps** 및 **Secrets**라는 즉시 사용 가능한 두 가지 강력한 구성 관리 기본 요소를 제공합니다.,以 Kubernetes 來說，執行容器只是其中的一個小環節。設定及管理應用程式同樣重要。Kubernetes 提供兩項功能強大的現成設定管理基元：**ConfigMap** 和 **Secret**
configmaps-secrets-notes-2,"Kubernetes **ConfigMaps** allow you to decouple configuration artifacts from image content to keep containerized applications portable. ConfigMaps allow environment specific data and files to be injected into your containers at runtime, allowing containers to be reused more easily.",利用 Kubernetes **ConfigMap**，您可以从映像内容中去除配置工件，以保证容器化应用的可移植性。ConfigMap 允许将特定于环境的数据和文件在运行时注入到容器中，从而实现更轻松地重用容器。,"Kubernetes **ConfigMaps**를 사용하면 이미지 콘텐츠에서 구성 아티팩트를 분리하여 컨테이너형 애플리케이션의 이동성을 유지할 수 있습니다. 또한 환경 관련 데이터 및 파일을 런타임에 컨테이너에 주입할 수 있으므로, 컨테이너를 보다 쉽게 재사용할 수 있습니다.",Kubernetes **ConfigMap** 可讓您將設定作業的相關構件與映像檔內容分離，藉此保持容器化應用程式的可攜性。有了 ConfigMap，環境專屬資料和檔案就能在執行階段中插入您的容器，讓您更輕鬆地重複使用容器。
configmaps-secrets-notes-3,"Kubernetes **Secrets** are similar, except they are for storing confidential information.",Kubernetes **Secret** 与之类似，只不过它们用于存储机密信息。,기밀 정보 저장에 사용된다는 것만 제외하면 Kubernetes **Secrets**도 비슷합니다.,Kubernetes **Secret** 的用途相差無幾，只不過 Secret 是用來儲存機密資訊。
combined-assignment,"Update the **frontend-deployment** Deployment to have an **environment variable** called **USERNAME** that gets its value from the ConfigMap you created, and another environment variable called **PASSWORD** that gets is value from the Secret you created. \n\n cURL the exposed service, and save the output of the service to a file called **finished.txt**\n\nThe `deployment.yaml` file has been updated for you to use.",更新 **frontend-deployment** 部署以设置一个名为 **USERNAME** 的**环境变量**（该变量从您创建的 ConfigMap 中获取值），以及另一个名为 **PASSWORD** 的环境变量（该变量从您创建的 Secret 中获取值）。\n\n对公开的服务运行 cURL 命令，并将服务的输出保存到名为 **finished.txt** 的文件中\n\n“deployment.yaml”已经更新以供您使用。,"사용자가 만든 ConfigMap에서 값을 가져오는 **USERNAME**이라는 **환경 변수**와 사용자가 만든 Secret에서 값을 가져오는 **PASSWORD**라는 또 다른 환경 변수가 포함되도록 **frontend-deployment** Deployment를 업데이트하세요. \n\n 제공된 서비스를 cURL로 실행하고, 서비스 출력을 **finished.txt**라는 파일에 저장하세요.\n\n사용이 가능하도록 `deployment.yaml` 파일이 업데이트되어 있습니다.",請更新 **frontend-deployment** Deployment，藉此取得名為 **USERNAME** 的 **環境變數**，這項變數會從您建立的 ConfigMap 取得資料值，另一項名為 **PASSWORD** 的環境變數則會從您建立的 Secret 取得資料值。 \n\n 使用 cURL 執行已公開發布的服務，並將該項服務的輸出內容儲存至名為 **finished.txt** 的檔案\n\n「deployment.yaml」檔案已更新完畢，可供您使用。