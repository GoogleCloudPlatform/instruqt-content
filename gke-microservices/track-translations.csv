key,en,zh-cn
slug,gke-microservices,gke-microservices-simplifiedchinese
teaser,Are you a master of microservices?,您是否精通微服务？
description,"Kubernetes Engine is a managed, production-ready environment for deploying and managing containerized applications. It brings our latest innovations in developer productivity, resource efficiency, automated operations, and open source flexibility to accelerate your time to market.",Kubernetes Engine 是一种支持生产工作负载的托管式环境，可用于部署和管理容器化应用。它提供我们在开发者工作效率、资源效率、自动化运维和开源灵活性领域的最新创新技术，帮助您缩短产品上市时间。
namespace-assignment,"A GKE Cluster has been provisioned for you, and the **kubectl** CLI has been pre-authenticated.\n\nCreate a namespace called **challenge**",系统已为您预配了一个 GKE 集群，并且已预先对 **kubectl** CLI 进行了身份验证。\n\n创建一个名为 **challenge** 的命名空间
namespace-notes-1,"Google Kubernetes Engine is a **fully managed and enterprise grade** Kubernetes platform. \n\nWith Kubernetes Engine you can focus on deploying and managing **containerized microservices** while leaving the **node, network, and other low level maintenance** to Google.",Google Kubernetes Engine 是一个**完全托管的企业级** Kubernetes 平台。\n\n利用 Kubernetes Engine，您可以集中精力来部署和管理**容器化微服务**，而将**节点、网络和其他低级别的维护工作**交给 Google 处理。
namespace-notes-2,"Kubernetes Engine is a **Certified Kubernetes** platform with many additional features designed to give you the power and flexibility you need. \n\nFrom **built in autoscaling, VPC native networking, global load balancing, and addons like Knative and Istio**, Kubernetes Engine gives you the tools you need to build **cloud native applications**.",Kubernetes Engine 是**经过认证的 Kubernetes**平台，还提供许多额外的功能，旨在为您提供所需的处理能力和灵活性。\n\n从**内置自动扩缩、VPC 原生网络、全局负载平衡，到 Knative 和 Istio 等插件**，Kubernetes Engine 为您提供了构建**云原生应用**所需的一切工具。
namespace-notes-3,One of the most important concepts in Kubernetes is that of a **Namespace**. Namespaces are used to organize resources in your cluster.,Kubernetes 中最重要的概念之一是**命名空间**。命名空间用于整理集群中的资源。
deployment-assignment,"In the **challenge** namespace you previously created, create a **Deployment** called **frontend-deployment** that runs a single Pod with the **gcr.io/gke-arcade/challenge** image.\nThe Pod should be labeled with **role = frontend**.\nThere is a partial file called `deployment.yaml` that has been created for you to use.",在您之前创建的 **challenge** 命名空间中，创建一个名为 **frontend-deployment**、运行使用 **gcr.io/gke-arcade/challenge** 映像的单个 Pod 的**部署**。\n此 Pod 应具有 **role = frontend** 标签。\n系统创建了一个名为“deployment.yaml”的部分文件供您使用。
deployment-notes-1,"One of the fundamental building blocks of Kubernetes is the **Pod**. Pods are a group of one or more containers that are scheduled together, for example a web server and a log collector.",Kubernetes 的基本构件之一是 **Pod**。Pod 是一同调度的一组（一个或多个）容器，例如 Web 服务器或日志收集器。
deployment-notes-2,"Pods are scheduled onto the cluster with a scheduler. The most common scheduler is a **Deployment**. Deployments let you run, scale, and update your Pods in a declarative fashion.",Pod 由调度程序调度到集群中。最常用的调度程序是**部署**。部署允许您以声明式方式运行、扩缩和更新 Pod。
service-assignment,"In the **challenge** namespace you previously created, create a **Service** called **frontend-service** of type **LoadBalancer** that routes traffic from port 80 to port 3000 of the pods in the `frontend-deployment` Deployment.\n\n(remember, the pods are labeled ""role = frontend"")\n\ncURL the exposed service, and save the output of the service to a file called **output.txt**\n\nThere is another partial file called `service.yaml` that has been created for you to use.",在您之前创建的 **challenge** 命名空间中，创建一项名为 **frontend-service**、类型为 **LoadBalancer** 的**服务**，用于将端口 80 上的流量路由到“frontend-deployment”部署中的 Pod 的端口 3000。\n\n（请记住，这些 Pod 具有“role = frontend”标签）\n\n对公开的服务运行 cURL 命令，并将服务的输出保存至一个名为 **output.txt** 的文件。\n\n系统还创建了一个名为“service.yaml”的部分文件供您使用。
service-notes-1,"While Deployments run your containers, **Services** tie them all together. Services act a service discovery and load balancing endpoints for your microservices. \nThis allows you to run multiple copies of your app without worrying about how other microservices in the cluster will find them.",部署运行容器，而**服务**将容器全部绑定到一起。服务充当微服务的服务发现和负载平衡端点。\n这样，您可以运行应用的多个副本，而不必担心集群中的其他微服务如何找到它们。
service-notes-2,"Services also let you create Network Load Balancers on GCP, allowing you to expose your microservices directly to the world behind an automatically configured and scalable load balancer.",利用服务，您还可以在 GCP 上创建网络负载平衡器，从而通过自动配置的可扩缩负载平衡器直接向世界公开您的微服务。
configmaps-secrets-assignment,"In the **challenge** namespace you previously created, create a **ConfigMap** called **prod-configmap** with a key named **username** with _any value_.\n\nThen create a **generic Secret** called **prod-secret** with a key named **password** with _any value_ in the **challenge namespace**.",在您之前创建的 **challenge** 命名空间中，创建一个名为 **prod-configmap** 的 **ConfigMap**，它具有值为_任意值_的 **username** 的键。\n\n然后在 **challenge 命名空间**中创建一个名为 **prod-secret** 的**常规 Secret**，它具有值为_任意值_的 **password** 的键。
configmaps-secrets-notes-1,Running your containers is just the tip of the iceberg when it comes to Kubernetes. Configuring and managing your app is equally important. Kubernetes provides two powerful config management primitives out of the box: **ConfigMaps** and **Secrets**,对于 Kubernetes ，运行容器只是冰山一角。配置和管理应用同样重要。Kubernetes 提供两种现成的功能强大的配置管理基本组件：**ConfigMap** 和 **Secret**
configmaps-secrets-notes-2,"Kubernetes **ConfigMaps** allow you to decouple configuration artifacts from image content to keep containerized applications portable. ConfigMaps allow environment specific data and files to be injected into your containers at runtime, allowing containers to be reused more easily.",利用 Kubernetes **ConfigMap**，您可以从映像内容中去除配置工件，以保证容器化应用的可移植性。ConfigMap 允许将特定于环境的数据和文件在运行时注入到容器中，从而实现更轻松地重用容器。
configmaps-secrets-notes-3,"Kubernetes **Secrets** are similar, except they are for storing confidential information.",Kubernetes **Secret** 与之类似，只不过它们用于存储机密信息。
combined-assignment,"Update the **frontend-deployment** Deployment to have an **environment variable** called **USERNAME** that gets its value from the ConfigMap you created, and another environment variable called **PASSWORD** that gets is value from the Secret you created. \n\n cURL the exposed service, and save the output of the service to a file called **finished.txt**\n\nThe `deployment.yaml` file has been updated for you to use.",更新 **frontend-deployment** 部署以设置一个名为 **USERNAME** 的**环境变量**（该变量从您创建的 ConfigMap 中获取值），以及另一个名为 **PASSWORD** 的环境变量（该变量从您创建的 Secret 中获取值）。\n\n对公开的服务运行 cURL 命令，并将服务的输出保存到名为 **finished.txt** 的文件中\n\n“deployment.yaml”已经更新以供您使用。